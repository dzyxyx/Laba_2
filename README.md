# ЭКОНОМИЧЕСКИЕ МОДЕЛИ В ИГРАХ (В РАБОТЕ)
Отчет по лабораторной работе #2 выполнил:
- Климченко Александр Викторович
- РИ-221110
Отметка о выполнении заданий (заполняется студентом):

| Задание | Выполнение | Баллы |
| ------ | ------ | ------ |
| Задание 1 | * | 60 |
| Задание 2 | * | 20 |
| Задание 3 | * | 20 |

знак "*" - задание выполнено; знак "#" - задание не выполнено;

Работу проверили:
- к.т.н., доцент Денисов Д.В.
- к.э.н., доцент Панов М.А.
- ст. преп., Фадеев В.О.

Структура отчета

- Данные о работе:
- Цель работы.
- Задание 1.
- Выберите одну из компьютерных игр, приведите скриншот её геймплея и краткое описание концепта игры. Выберите одну из игровых переменных в игре (ресурсы, внутри игровая валюта, здоровье персонажей и т.д.), опишите её роль в игре, условия изменения / появления и диапазон допустимых значений. Постройте схему экономической модели в игре и укажите место выбранного ресурса в ней.
- Задание 2.
- С помощью скрипта на языке Python заполните google-таблицу данными, описывающими выбранную игровую переменную в выбранной игре (в качестве таких переменных может выступать игровая валюта, ресурсы, здоровье и т.д.). Средствами google-sheets визуализируйте данные в google-таблице (постройте график, диаграмму и пр.) для наглядного представления выбранной игровой величины.
- Задание 3.
- Настройте на сцене Unity воспроизведение звуковых файлов, описывающих динамику изменения выбранной переменной. Например, если выбрано здоровье главного персонажа вы можете выводить сообщения, связанные с его состоянием.
- Выводы.
- ✨Magic ✨

## Цель работы
Научиться передавать в Unity данные из Google Sheets с помощью Python.

## Задание 1
Для выполнения 1 задания в данной лабораторной работе, я выбрал игру "Sekiro: Shadows Die Twice". Студия FromSoftware, создавшая серию Dark Souls, является создателем и игры, которая будет рассматриваться в качестве примера.
Sekiro: Shadows Die Twice - это экшен-приключение, действие которого происходит в Японии в эпоху Сэнгоку. Игрок играет за ниндзя-воина по имени Секиро, который был преданным слугой лорда и потерял свою руку в битве. Он получает новую протезную руку, которая позволяет ему использовать различные оружия и инструменты.

Игрок будет исследовать различные уровни, сражаться с врагами и боссами, а также выполнять задания, чтобы достичь своей цели - спасти своего господина. В игре будут доступны различные способы прохождения уровней, включая скрытность, боевые приемы и использование инструментов.

Особое внимание уделено боям с боссами, которые будут представлять собой настоящие испытания для игрока. Каждый босс будет иметь свои уникальные атаки и слабости, и игрок должен будет использовать свои навыки и оружие, чтобы победить их.

В игре будут доступны различные виды оружия и инструментов, которые можно будет улучшать и модифицировать. Игрок сможет также улучшать свои навыки и способности, чтобы стать еще более сильным и эффективным в боях.

Sekiro: Shadows Die Twice - это игра с глубоким сюжетом, который будет раскрываться по мере прохождения игры. Игрок будет узнавать больше о мире игры, его истории и персонажах, а также принимать решения, которые будут влиять на исход игры.

Ниже на скринах представлены части игровой механики:
![image](https://github.com/dzyxyx/Laba_2/assets/152580474/30883754-cb19-462a-996d-fe039ad9798a)
					Рисунок 1.

![image](https://github.com/dzyxyx/Laba_2/assets/152580474/465a9c7e-5582-4775-a527-d6660115c0a0)
					Рисунок 2.


Для выполнения задания возьмем переменную концентрации. 
- Концентрация в игре Sekiro: Shadows Die Twice играет важную роль, так как позволяет персонажу использовать специальные приемы и умения. Концентрация заполняется по мере нанесения урона врагам и блокирования их атак. Она также может быть восстановлена с помощью специальных предметов и умений. Визуально "полоска" концентрации приведена на рисунке 2 снизу в центре скриншота.

- Уровень концентрации может быть изменен с помощью умений и предметов, которые увеличивают его максимальное значение. Диапазон допустимых значений концентрации зависит от уровня персонажа и его характеристик. Например, на начальных уровнях концентрация может быть ограничена до 3 единиц, в то время как на более высоких уровнях она может достигать 10 единиц. Рассмотрим значения концентрации на финальном этапе игры, где она может принимать значения 0-10.
![image](https://github.com/dzyxyx/Laba_2/assets/152580474/dcf26cda-ecc0-4852-9f18-4180ddefa7df)
рисунок 3.

На экономической модели (Рисунок 3) показано, что концентрация связана с здоровьем, т.е. занимает второе место по важности переменных в игре, от нее зависит, как успешное убийство игровых мобов, так и уменьшение хп персонажа. В результате изменения здоровья и концентрации получаем предметы и внутриигровую валюту, которую можно обменивать на предметы/ресурсы.


## Задание 2
### С помощью скрипта на языке Python заполните google-таблицу данными, описывающими выбранную игровую переменную в выбранной игре (в качестве таких переменных может выступать игровая валюта, ресурсы, здоровье и т.д.). Средствами google-sheets визуализируйте данные в google-таблице (постройте график, диаграмму и пр.) для наглядного представления выбранной игровой величины.

Таблица: https://docs.google.com/spreadsheets/d/1mMxjptawbBBYV1FXPN4T2OiBj2aC7FDyNIPXGy2bdCE/edit#gid=0

Исходный код заполнения данных:

```py

import gspread
import numpy as np

gc = gspread.service_account(filename='laba2-408011-e0b10d495c9a.json')
sh = gc.open("laba2")
price = np.random.randint(0, 11, 10)
mon = list(range(1, 11))

# Проверка на достижение до значения 10
j = 0
for j in mon:
    if price[j-1] == 10:
        price[j] = 0 # Установка последующего значения элемента равному 0

print(price)

i = 0
tempInf = 0 # задаем начальное значение переменной tempInf
while i < len(mon):
    i += 1
    if i == 1: # для первой итерации цикла
        tempInf = price[i-1] # значение tempInf равно первому элементу списка price
    else:
        tempInf = price[i-1]-price[i-2] # для остальных итераций значение tempInf равно разности текущего и предыдущего элементов списка price
    sh.sheet1.update(('A' + str(i)), str(i)) # Заполнение ячеек столбца А
    sh.sheet1.update(('B' + str(i)), str(price[i-1])) # Заполнение ячеек столбца В
    sh.sheet1.update(('C' + str(i)), str(tempInf)) # Заполнение ячеек столбца С
    print(price[i-1], tempInf) # Проверка на соответсвие значений, заполняемых в таблице

```
У меня не получилось сделать google таблицу, поэтому я разберу код на примере значений, указанных на рисунке 4.
![image](https://github.com/dzyxyx/Laba_2/assets/152580474/ca7c0120-588c-48d9-bdae-c62a7ac7ff3c)
Рисунок 4.
В столбце А указан порядок генерации заполнения шкалы концентрации, столбец B - непосредственно значения концентрации в определенный момент, столбец C - разница между текущим номером и предыдущим, используется для отображения изменения параметра концентрации.

В исходном коде программы происходит генерация чисел для заполнения параметра концентрации в определенный момент времени. Параметр может принимать значения от 0 до 10. При достижении параметром значения 10 происходит обнуление шкалы, т.е происходит вывод персонажа из концентрации и в течении 1-2 секунд игрок не сможет производить действия персонажем. На графике визуально показано изменение параметра.

Так же необходимо было обнулять каждый раз значение параметра концентрации при повторном заполнении таблицы, для этого в коде было прописано начальное значение переменной tempInf = 0.


## Задание 3
### Настройте на сцене Unity воспроизведение звуковых файлов, описывающих динамику изменения выбранной переменной. Например, если выбрано здоровье главного персонажа вы можете выводить сообщения, связанные с его состоянием.

Исходный код программы
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;
using SimpleJSON;

public class NewBehaviourScript : MonoBehaviour
{
    public AudioClip goodSpeak;
    public AudioClip normalSpeak;
    public AudioClip badSpeak;
    private AudioSource selectAudio;
    private Dictionary<string,float> dataSet = new Dictionary<string, float>();
    private bool statusStart = false;
    private int i = 1;

    // Start is called before the first frame update
    void Start()
    {
        StartCoroutine(GoogleSheets());
    }

    // Update is called once per frame
    void Update()
    {
        if(dataSet.Count == 0) return;
        if (dataSet["Mon_" + i.ToString()] < 0 & statusStart == false & i != dataSet.Count)
        {
            StartCoroutine(PlaySelectAudioGood());
            Debug.Log(dataSet["Mon_" + i.ToString()]);
        }

        if (dataSet["Mon_" + i.ToString()] >= 0 & dataSet["Mon_" + i.ToString()] < 100 & statusStart == false & i != dataSet.Count)
        {
            StartCoroutine(PlaySelectAudioNormal());
            Debug.Log(dataSet["Mon_" + i.ToString()]);
        }

        if (dataSet["Mon_" + i.ToString()] > 5 & statusStart == false & i != dataSet.Count)
        {
            StartCoroutine(PlaySelectAudioBad());
            Debug.Log(dataSet["Mon_" + i.ToString()]);
        }
    }

    IEnumerator GoogleSheets()
    {
        UnityWebRequest curentResp = UnityWebRequest.Get("https://sheets.googleapis.com/v4/spreadsheets/1mMxjptawbBBYV1FXPN4T2OiBj2aC7FDyNIPXGy2bdCE/values/Лист1?key=AIzaSyBTO_SJ4F01pGQUil9dlE0bFU0gFy_8Qp8");
        yield return curentResp.SendWebRequest();
        string rawResp = curentResp.downloadHandler.text;
        var rawJson = JSON.Parse(rawResp);
        foreach (var itemRawJson in rawJson["values"])
        {
            var parseJson = JSON.Parse(itemRawJson.ToString());
            var selectRow = parseJson[0].AsStringList;
            dataSet.Add(("Mon_" + selectRow[0]), float.Parse(selectRow[2]));
        }
    }

    IEnumerator PlaySelectAudioGood()
    {
        statusStart = true;
        selectAudio = GetComponent<AudioSource>();
        selectAudio.clip = goodSpeak;
        selectAudio.Play();
        yield return new WaitForSeconds(3);
        statusStart = false;
        i++;
    }
    IEnumerator PlaySelectAudioNormal()
    {
        statusStart = true;
        selectAudio = GetComponent<AudioSource>();
        selectAudio.clip = normalSpeak;
        selectAudio.Play();
        yield return new WaitForSeconds(3);
        statusStart = false;
        i++;
    }
    IEnumerator PlaySelectAudioBad()
    {
        statusStart = true;
        selectAudio = GetComponent<AudioSource>();
        selectAudio.clip = badSpeak;
        selectAudio.Play();
        yield return new WaitForSeconds(4);
        statusStart = false;
        i++;
    }
}
```
В данном задании было произведено воспроизведение звуков при изменении значений. При уменьшении значения воспроизводится horosho, при значениях выше нуля воспроизводится звук sredne, при значениях выше 5 воспроизводится звук ploho.
Для считывания значений было необходимо поменять ссылку на таблицу, которая заполняется значениями, исходя из кода 2го задания и вставить API ключ.
Так же в коде были изменены условия воспроизведения звуков.

##Выводы
- В данной лабораторной работе мы научили заполнять таблицу значениями при помощь языка программирования Python. Так же научились считывать значения из таблицы и исходя из их изменения воспроизводить звуки объекта на Unity.

## Powered by

**BigDigital Team: Denisov | Fadeev | Panov**
